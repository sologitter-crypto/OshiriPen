<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Swarm Game</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #003f67; touch-action: none; }
        canvas { display: block; }
        
        /* スコア */
        #score {
            position: absolute; top: 20px; left: 30px;
            color: white; font-family: Futura, sans-serif; font-size: 40px;
            pointer-events: none; user-select: none;
            z-index: 10;
        }

        /* タイマー */
        #timer {
            position: absolute; top: 20px; right: 30px;
            color: #ffcc00; font-family: Futura, sans-serif; font-size: 40px;
            pointer-events: none; user-select: none;
            z-index: 10;
        }

        /* ゲームオーバー */
        #gameOver {
            position: absolute; top: 40%; left: 50%;
            transform: translate(-50%, -50%) scale(0);
            color: red; font-family: Futura, sans-serif; font-size: 60px; font-weight: bold;
            pointer-events: none; transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            white-space: nowrap;
            z-index: 20;
            text-shadow: 2px 2px 0 #fff;
        }

        /* クリア */
        #gameClear {
            position: absolute; top: 40%; left: 50%;
            transform: translate(-50%, -50%) scale(0);
            color: #00ff00;
            font-family: Futura, sans-serif; font-size: 60px; font-weight: bold;
            pointer-events: none; transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            white-space: nowrap;
            z-index: 20;
            text-shadow: 2px 2px 0 #000;
        }

        /* リトライボタン */
        #retryBtn {
            position: absolute; top: 60%; left: 50%;
            transform: translate(-50%, -50%);
            background: white; color: #003f67;
            font-family: Futura, sans-serif; font-size: 24px; font-weight: bold;
            padding: 10px 40px; border-radius: 30px;
            cursor: pointer; display: none;
            z-index: 30;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        #retryBtn:active {
            transform: translate(-50%, -50%) scale(0.95);
            background: #eee;
        }

        /* スタート画面 */
        #startOverlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5); display: flex;
            justify-content: center; align-items: center; color: white; font-size: 24px;
            font-family: sans-serif; cursor: pointer;
            z-index: 40;
        }
    </style>
</head>
<body>

<div id="score">0</div>
<div id="timer">0.00</div>
<div id="gameOver">GAME OVER</div>
<div id="gameClear">CLEAR!!</div>
<div id="retryBtn">RETRY</div>
<div id="startOverlay">Tap to Start</div>
<canvas id="gameCanvas"></canvas>

<script>
// --- 設定 (バランス調整) ---
const SWARM_SIZE = 6;
const MAX_SPEED = 4;
const PANIC_SPEED = 8;
const COLLISION_DISTANCE = 40; 
const KISS_COOLDOWN = 60;
const GAME_OVER_LIMIT = 5;
const CLEAR_TIME = 7.0;

// ★難易度調整箇所
const FLEE_FORCE = 0.3;      // 逃げる力 (0.5 -> 0.3 に弱体化)
const RETURN_FORCE = 1.0;    // 画面に戻る力 (0.2 -> 1.0 に強化)
const PANIC_DURATION = 300;  // パニック時間ms (500 -> 300 に短縮)

// --- アセット読み込み ---
const images = {};
const sounds = {};
const assetList = {
    boid1: 'IMG_8941.PNG',
    boid2: 'IMG_8943.PNG',
    bg: 'IMG_8945.PNG',
    heart: 'IMG_8949.png' 
};
const soundList = {
    kiss: 'おしりぺん.m4a',
    panic: 'わぁ〜.m4a',
    gameOver: 'game_over.mp3'
};

for (let key in assetList) {
    images[key] = new Image();
    images[key].src = assetList[key];
}
for (let key in soundList) {
    sounds[key] = new Audio(soundList[key]);
}

function playSound(name) {
    const s = sounds[name];
    if (s) {
        const clone = s.cloneNode();
        clone.volume = 0.5;
        clone.play().catch(e => console.log("Audio blocked:", e));
    }
}

// --- ゲーム変数 ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const timerEl = document.getElementById('timer');
const gameOverEl = document.getElementById('gameOver');
const gameClearEl = document.getElementById('gameClear');
const retryBtn = document.getElementById('retryBtn');
const startOverlay = document.getElementById('startOverlay');

let width, height;
let swarm = [];
let kissCount = 0;
let isGameOver = false;
let startTime = 0;
let effects = [];

// Boidクラス
class Boid {
    constructor() {
        this.imgKey = Math.random() < 0.5 ? 'boid1' : 'boid2';
        this.x = Math.random() * width;
        this.y = Math.random() * height;
        const a = Math.random() * Math.PI * 2;
        this.vx = Math.cos(a) * 2;
        this.vy = Math.sin(a) * 2;
        this.kissTimer = 0;
        this.startled = false;
        this.fleePos = null;
    }

    update(neighbors) {
        if (this.kissTimer > 0) this.kissTimer--;

        // Separation
        let cx = 0, cy = 0;
        neighbors.forEach(n => {
            const dx = n.x - this.x;
            const dy = n.y - this.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < 30) {
                cx -= dx;
                cy -= dy;
            }
        });
        this.vx += cx * 0.05;
        this.vy += cy * 0.05;

        // Alignment
        if (neighbors.length > 0) {
            let avgVx = 0, avgVy = 0;
            neighbors.forEach(n => {
                avgVx += n.vx;
                avgVy += n.vy;
            });
            avgVx /= neighbors.length;
            avgVy /= neighbors.length;
            this.vx += avgVx * 0.05;
            this.vy += avgVy * 0.05;
        }

        // Bounds (強化された戻る力を使用)
        if (this.x < 0) this.vx += MAX_SPEED * RETURN_FORCE;
        if (this.x > width) this.vx -= MAX_SPEED * RETURN_FORCE;
        if (this.y < 0) this.vy += MAX_SPEED * RETURN_FORCE;
        if (this.y > height) this.vy -= MAX_SPEED * RETURN_FORCE;

        // Panic (弱体化された逃げる力を使用)
        if (this.startled && this.fleePos) {
            const dx = this.x - this.fleePos.x;
            const dy = this.y - this.fleePos.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist > 0) {
                this.vx += (dx / dist) * FLEE_FORCE * 5;
                this.vy += (dy / dist) * FLEE_FORCE * 5;
            }
        }

        // Speed Limit
        const speed = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
        const limit = this.startled ? PANIC_SPEED : MAX_SPEED;
        if (speed > limit) {
            this.vx = (this.vx / speed) * limit;
            this.vy = (this.vy / speed) * limit;
        }

        this.x += this.vx;
        this.y += this.vy;
    }

    draw() {
        const img = images[this.imgKey];
        if (!img.complete) return;
        
        ctx.save();
        ctx.translate(this.x, this.y);
        const angle = Math.atan2(this.vy, this.vx);
        ctx.rotate(angle + Math.PI);
        const size = 100;
        ctx.drawImage(img, -size/2, -size/2, size, size);
        ctx.restore();
    }
}

class HeartEffect {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.life = 1.0;
    }
    update() {
        this.y -= 1;
        this.life -= 0.02;
    }
    draw() {
        ctx.save();
        ctx.globalAlpha = Math.max(0, this.life);
        const img = images['heart'];
        const size = 30;
        if (img.complete) ctx.drawImage(img, this.x - size/2, this.y - size/2, size, size);
        ctx.restore();
    }
}

function resize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

function initGame() {
    swarm = [];
    for (let i = 0; i < SWARM_SIZE; i++) {
        swarm.push(new Boid());
    }
    startTime = Date.now();
    startOverlay.style.display = 'none';
    timerEl.textContent = CLEAR_TIME.toFixed(2);
    loop();
}

function resetGame() {
    isGameOver = false;
    kissCount = 0;
    scoreEl.textContent = '0';
    effects = [];
    
    swarm = [];
    for (let i = 0; i < SWARM_SIZE; i++) {
        swarm.push(new Boid());
    }
    
    startTime = Date.now();

    gameOverEl.style.transform = "translate(-50%, -50%) scale(0)";
    gameClearEl.style.transform = "translate(-50%, -50%) scale(0)";
    retryBtn.style.display = 'none';

    loop();
}

function loop() {
    if (isGameOver) return;
    requestAnimationFrame(loop);

    const elapsed = (Date.now() - startTime) / 1000;
    let remain = CLEAR_TIME - elapsed;
    
    if (remain <= 0) {
        remain = 0;
        doGameClear();
    }
    timerEl.textContent = remain.toFixed(2);
    
    if (isGameOver) return;

    ctx.fillStyle = '#003f67';
    ctx.fillRect(0, 0, width, height);
    if (images['bg'].complete) {
        ctx.drawImage(images['bg'], 0, 0, width, height);
    }

    const neighborDist = Math.min(width, height) / 3;

    swarm.forEach((boid, i) => {
        let neighbors = [];
        swarm.forEach((other, j) => {
            if (i === j) return;
            const dx = boid.x - other.x;
            const dy = boid.y - other.y;
            if (Math.sqrt(dx*dx + dy*dy) < neighborDist) {
                neighbors.push(other);
            }
        });

        boid.update(neighbors);
        boid.draw();
    });

    for (let i = 0; i < swarm.length; i++) {
        for (let j = i + 1; j < swarm.length; j++) {
            let b1 = swarm[i];
            let b2 = swarm[j];
            if (b1.kissTimer === 0 && b2.kissTimer === 0) {
                const dx = b1.x - b2.x;
                const dy = b1.y - b2.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist < COLLISION_DISTANCE) {
                    triggerKiss(b1, b2);
                }
            }
        }
    }

    for (let i = effects.length - 1; i >= 0; i--) {
        effects[i].update();
        effects[i].draw();
        if (effects[i].life <= 0) effects.splice(i, 1);
    }
}

function triggerKiss(b1, b2) {
    if (isGameOver) return;

    playSound('kiss');
    b1.kissTimer = KISS_COOLDOWN;
    b2.kissTimer = KISS_COOLDOWN;
    
    kissCount++;
    scoreEl.textContent = kissCount;

    if (kissCount >= GAME_OVER_LIMIT) {
        doGameOver();
        return;
    }

    effects.push(new HeartEffect((b1.x + b2.x)/2, (b1.y + b2.y)/2));
}

function doGameOver() {
    isGameOver = true;
    playSound('gameOver');
    gameOverEl.style.transform = "translate(-50%, -50%) scale(1.2)";
    setTimeout(() => {
        gameOverEl.style.transform = "translate(-50%, -50%) scale(1.0)";
    }, 200);

    setTimeout(() => {
        retryBtn.style.display = 'block';
    }, 800);
}

function doGameClear() {
    isGameOver = true;
    gameClearEl.style.transform = "translate(-50%, -50%) scale(1.2)";
    setTimeout(() => {
        gameClearEl.style.transform = "translate(-50%, -50%) scale(1.0)";
    }, 200);

    setTimeout(() => {
        retryBtn.style.display = 'block';
    }, 800);
}

function handleInput(x, y) {
    if (isGameOver) return;
    
    playSound('panic');
    
    const flash = document.createElement('div');
    flash.style.position = 'absolute';
    flash.style.left = (x - 50) + 'px';
    flash.style.top = (y - 50) + 'px';
    flash.style.width = '100px';
    flash.style.height = '100px';
    flash.style.borderRadius = '50%';
    flash.style.backgroundColor = 'white';
    flash.style.opacity = '1';
    flash.style.transition = 'all 0.5s';
    flash.style.pointerEvents = 'none';
    document.body.appendChild(flash);
    
    setTimeout(() => {
        flash.style.transform = 'scale(2)';
        flash.style.opacity = '0';
    }, 10);
    setTimeout(() => flash.remove(), 500);

    swarm.forEach(b => {
        b.startled = true;
        b.fleePos = {x: x, y: y};
    });

    // パニック時間を定数で管理
    setTimeout(() => {
        swarm.forEach(b => {
            b.startled = false;
            b.fleePos = null;
        });
    }, PANIC_DURATION);
}

canvas.addEventListener('mousedown', e => {
    handleInput(e.clientX, e.clientY);
});
canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    const touch = e.touches[0];
    handleInput(touch.clientX, touch.clientY);
}, {passive: false});

startOverlay.addEventListener('click', initGame);
startOverlay.addEventListener('touchstart', (e) => {
    e.preventDefault(); 
    initGame();
});

retryBtn.addEventListener('click', resetGame);
retryBtn.addEventListener('touchstart', (e) => {
    e.stopPropagation();
    resetGame();
});

</script>
</body>
</html>
